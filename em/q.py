import random
from io import StringIO
from contextlib import redirect_stdout

FILE = "em/questions.txt"
MAX_LINE_WIDTH = 80

def printw(s, width=MAX_LINE_WIDTH):
    char_list = []
    num_chars = 0
    for c in s:
        char_list.append(c)
        num_chars += 1
        if num_chars == width:
            print("".join(char_list))
            char_list = []
            num_chars = 0
    if len(char_list) > 0:
        print("".join(char_list))

def a0():
    printw("- Python is a high-level, interpreted, interactive, and object-oriented scripting language. It uses English  keywords frequently. Whereas, other languages use punctuation, Python has fewer syntactic constructions.")
    print()
    printw("- Python is designed to be highly readable and compatible with different platforms such as Mac, Windows, Linux, Raspberry Pi, etc.")
    print()

def a1():
    printw("An interpreted language is any programming language which executes its statements line by line.Programs written in Python run directly from the source code, with no intermediary compilation step.")
    print()

def a2():
    printw("LIST: Lists are mutable, i.e., they can be edited | TUPLE: Tuples are immutable (they are lists that cannot be edited)")
    print()
    printw("LIST: Lists are usually slower than tuples | TUPLE: Tuples are faster than lists")
    print()
    printw("LIST: Lists consume a lot of memory | TUPLE: Tuples consume less memory when compared to lists")
    print()
    printw("LIST: Lists are less reliable in terms of errors as unexpected changes are more likely to occur | TUPLE: Tuples are more reliable as it is hard for any unexpected change to occur")
    print()
    printw("LIST: Lists consist of many built-in functions. | TUPLE: Tuples do not consist of any built-in functions.")
    print()
    printw("LIST: Syntax: list_1 = [10, 'Intellipaat', 20] | TUPLE: Syntax: tup_1 = (10, 'Intellipaat' , 20)")
    print()

def a3():
    printw("PEP in Python stands for Python Enhancement Proposal.It is a set of rules that specify how to write and design Python code for maximum readability.")
    print()

def a4():
    printw("The key features of Python are as follows:")
    printw("- Python is an interpreted language, so it doesn't need to be compiled before execution, unlike languages such as C")
    print()
    printw("- Python is dynamically typed, so there is no need to declare a variable with the data type. Python Interpreter will identify the data type on the basis of the value of the variable. For example, in Python, the following code line will run without any error:")
    printw("```")
    printw("a = 10")
    printw("a = \"Intellipaat\"")
    printw("```")
    print()
    printw("- Python follows an object-oriented programming paradigm with the exception of having access specifiers. Other than access specifiers (public and private keywords), Python has classes, inheritance, and all other usual OOPs concepts.")
    print()
    printw("- Python is a cross-platform language, i.e., a Python program written on a Windows system will also run on a Linux system with little or no modifications at all.")
    print()
    printw("- Python is literally a general-purpose language, i.e., Python finds its way in various domains such as web application development, automation, Data Science, Machine Learning, and more.")
    print()

def a5():
    printw("- Memory in Python is managed by Python private heap space. All Python objects and data structures are located in a private heap. This private heap is taken care of by Python Interpreter itself, and a programmer doesn't have access to this private heap.")
    print()
    printw("- Python memory manager takes care of the allocation of Python private heap space.")
    print()
    printw("- Memory for Python private heap space is made available by Python's in-built garbage collector, which recycles and frees up all the unused memory.")
    print()

def a6():
    printw("PYTHONPATH has a role similar to PATH. This variable tells Python Interpreter where to locate the module files imported into a program. It should include the Python source library directory and the directories containing Python source code. PYTHONPATH is sometimes preset by Python Installer.")
    print()

def a7():
    printw("Files containing Python codes are referred to as Python Modules.This code can either be classes,functions or variables and saves the programmer time by providing the predefined functionalities when needed.It is a file with .py extension containing an executable code.")
    print()
    printw("Commonly used built modules are listed below:")
    printw("- os")
    printw("- sys")
    printw("- datetime")
    printw("- math")
    printw("- random")
    printw("- JSON")
    print()

def a8():
    printw("A Python namespace ensures that object names in a program are unique and can be used without any conflict. Python implements these namespaces as dictionaries with 'name as key' mapped to its respective 'object as value'.Let's explore some examples of namespaces:")
    printw("- Local Namespace: consists of local names inside a function. It is temporarily created for a function call and gets cleared once the function returns.")
    print()
    printw("- Global Namespace: consists of names from various imported modules/packages that are being used in the ongoing project. It is created once the package is imported into the script and survives till the execution of the script.")
    print()
    printw("- Built-in Namespace consists of built-in functions of core Python and dedicated built-in names for various types of exceptions.")
    print()

def a9():
    printw("As Python follows an object-oriented programming paradigm, classes in Python have the ability to inherit the properties of another class. This process is known as inheritance. Inheritance provides the code reusability feature. The class that is being inherited is called a superclass or the parent class, and the class that inherits the superclass is called a derived or child class. The following types of inheritance are supported in Python:")
    printw("- Single inheritance: When a class inherits only one superclass")
    print()
    printw("- Multiple inheritance: When a class inherits multiple superclasses")
    print()
    printw("- Multilevel inheritance: When a class inherits a superclass, and then another class inherits this derived class forming a 'parent, child, and grandchild' class structure")
    print()
    printw("- Hierarchical inheritance: When one superclass is inherited by multiple derived classes")
    print()

def a10():
    printw("A scope is a block of code where an object in Python remains relevant. Each and every object of python functions within its respective scope. As Namespaces uniquely identify all the objects inside a program but these namespaces also have a scope defined for them where you could use their objects without any prefix. It defines the accessibility and the lifetime of a variable.")
    print()
    printw("Let's have a look on scope created as the time of code execution:")
    printw("- A local scope refers to the local objects included in the current function.")
    print()
    printw("- A global scope refers to the objects that are available throughout execution of the code.")
    print()
    printw("- A module-level scope refers to the global objects that are associated with the current module in the program.")
    print()
    printw("- An outermost scope refers to all the available built-in names callable in the program.")
    print()

def a11():
    printw("Python dictionary is one of the supported data types in Python. It is an unordered collection of elements. The elements in dictionaries are stored as key-value pairs. Dictionaries are indexed by keys.")
    print()
    printw("For example, below we have a dictionary named 'dict'. It contains two keys, Country and Capital, along with their corresponding values, India and New Delhi.")
    printw("Syntax:")
    printw("```")
    printw("dict={'Country':'India','Capital':'New Delhi', }")
    printw("Output: Country: India, Capital: New Delhi")
    printw("```")
    print()

def a12():
    printw("A function is a block of code which is executed only when a call is made to the function. \"def\" keyword is used to define a particular function as shown below:")
    printw("```")
    printw("def function():")
    printw("    print(\"Hi, Welcome to Intellipaat\")")
    printw("function(); # call to the function")
    printw("```")
    print()
    printw("Output:")
    printw("Hi, Welcome to Intellipaat")
    print()

def a13():
    printw("Equivalent to constructors in OOP terminology, __init__ is a reserved method in Python classes. The __init__ method is called automatically whenever a new object is initiated. This method allocates memory to the new object as soon as it is created.  This method can also be used to initialize variables.")
    print()
    printw("Syntax:")
    printw("(for defining the __init__ method):")
    printw("```")
    printw("class Human:")
    printw("    # init method or constructor")
    printw("    def __init__(self, age):")
    printw("        self.age = age")
    printw("    # Sample Method")
    printw("    def say(self):")
    printw("        print('Hello, my age is', self.age)")
    printw("h = Human(22)")
    printw("h.say()")
    printw("```")
    print()
    printw("Output:")
    printw("Hello, my age is 22")
    print()

def a14():
    printw("Python supports the below-mentioned built-in data types:")
    printw("Immutable data types:")
    printw("- Number")
    printw("- String")
    printw("- Tuple")
    print()
    printw("Mutable data types:")
    printw("- List")
    printw("- Dictionary")
    printw("- set")
    print()

def a15():
    printw("- Local variable: Any variable declared inside a function is known as Local variable and it's accessibility remains inside that function only.")
    print()
    printw("- Global Variable: Any variable declared outside the function is known as Global variable and it can be easily accessible by any function present throughout the program.")
    print()
    printw("```")
    printw("g=4 #global variable")
    printw("def func_multiply():")
    printw("    l=5 #local variable")
    printw("    m=g*l")
    printw("    return m")
    printw("func_multiply()")
    printw("```")
    printw("Output: 20")
    print()
    printw("If you try to access the local variable outside the multiply function then you will end up with getting an error.")

def a16():
    printw("Python provides you with a much needed functionality of converting one form of data type into the needed one and this is known as type conversion.")
    printw(" ")
    printw("Type Conversion is classified into types:")
    printw("1.Implicit Type Conversion: In this form of Type conversion python interpreter helps in automatically converting the data ")
    printw("type into another data type without any User involvement.")
    printw(" ")
    printw("2.Explicit Type Conversion: In this form of Type conversion the data type inn changed into a required type by the user.")
    printw(" ")
    printw("Various Functions of explicit conversion are show below:")
    printw("int() - function converts any data type into integer.")
    printw("float() - function converts any data type into float.")
    printw("ord() - function converts characters into integer.")
    printw("hex() - function converts integers to hexadecimal strings.")
    printw("oct() - function converts integer to octal strings.")
    printw("tuple() - function convert to a tuple.")
    printw("set() - function returns the type after converting to set.")
    printw("list() - function converts any data type to a list type.")
    printw("dict() - function is used to convert a tuple of order (key,value) into a dictionary.")
    printw("str() - function used to convert integer into a string.")
    printw("complex(real,imag) - function used to convert real numbers to complex(real,imag) numbers.")
    printw(" ")

def a17():
    printw("For installing Python on Windows, follow the steps shown below:")
    printw("- Click on this link for installing the python: Download Python")
    printw("- After that, install it on your PC by looking for the location where PYTHON has been installed on your PC by executing the following command on command prompt;")
    printw("```")
    printw("cmd python.")
    printw("```")
    printw("- Visit advanced system settings and after that add a new variable and name it as PYTHON_NAME and paste the path that has been copied.")
    printw("- Search for the path variable -> select its value and then select 'edit'.")
    printw("- Add a semicolon at the end of the value if it's not present and then type %PYTHON_HOME%")
    printw(" ")

def a18():
    printw("LIST: Consists of elements belonging to different data types | ARRAY: Consists of only those elements having the same data type")
    printw(" ")
    printw("LIST: No need to import a module for list declaration | ARRAY: Need to explicitly import a module for array declaration")
    printw(" ")
    printw("LIST: Can be nested to have different type of elements | ARRAY: Must have all nested elements of the same size")
    printw("")
    printw("LIST: Recommended to use for shorter sequence of data items | ARRAY: Recommended to use for longer sequence of data items")
    printw(" ")
    printw("LIST: More flexible to allow easy modification (addition or deletion) of data | ARRAY: Less flexible since addition or deletion has to be done element-wise")
    printw(" ")
    printw("LIST: Consumes large memory for the addition of elements | ARRAY: Comparatively more compact in memory size while inserting elements")
    printw(" ")
    printw("LIST: Can be printed entirely without using looping | ARRAY: A loop has to be defined to print or access the components")
    printw(" ")
    printw("Syntax (LIST):")
    printw("```")
    printw("list = [1,\"Hello\",['a','e']]")
    printw("```")
    printw(" ")
    printw("Syntax (ARRAY):")
    printw("```")
    printw("import array")
    printw("array_demo = array.array('i', [1, 2, 3])")
    printw("(array as integer type)")
    printw("```")
    printw(" ")

def a19():
    printw("Yes,Python is a case sensitive language.This means that Function and function both are different in python alike SQL and Pascal.")
    printw(" ")

def a20():
    printw("[::-1] ,this is an example of slice notation and helps to reverse the sequence with the help of indexing.")
    printw(" ")
    printw("[Start,stop,step count]")
    printw(" ")
    printw("Let's understand with an example of an array:")
    printw("```")
    printw("import array as arr")
    printw("Array_d=arr.array('i',[1,2,3,4,5])")
    printw("Array_d[::-1] #reverse the array or sequence")
    printw("Output: 5,4,3,2,1")
    printw("```")
    printw(" ")

def a21():
    printw("A Python package refers to the collection of different sub-packages and modules based on the similarities of the function.")
    printw(" ")

def a22():
    printw("In Python, decorators are necessary functions that help add functionality to an existing function without changing the structure of the function at all. These are represented by @decorator_name in Python and are called in a bottom-up format.")
    printw(" ")
    printw("Let's have a look how it works:")
    printw("```")
    printw("def decorator_lowercase(function): # defining python decorator")
    printw("    def wrapper():")
    printw("        func = function()")
    printw("        input_lowercase = func.lower()")
    printw("        return input_lowercase")
    printw("    return wrapper")
    printw(" ")
    printw("@decorator_lowercase #calling decoractor")
    printw("def intro(): #Normal function")
    printw("    return 'Hello,I AM SAM'")
    printw(" ")
    printw("intro()")
    printw("```")
    printw(" ")
    printw("Output: 'hello,i am sam'")
    printw(" ")

def a23():
    printw("Indentation in Python is compulsory and is part of its syntax.")
    printw(" ")
    printw("All programming languages have some way of defining the scope and extent of the block of codes. In Python, it is indentation. Indentation provides better readability to the code, which is probably why Python has made it compulsory.")
    printw(" ")

def a24():
    printw("These statements help to change the phase of execution from the normal flow that is why they are termed loop control statements.")
    printw("- Python break: This statement helps terminate the loop or the statement and pass the control to the next statement.")
    printw(" ")
    printw("- Python continue: This statement helps force the execution of the next iteration when a specific condition meets, instead of terminating it.")
    printw(" ")
    printw("- Python pass: This statement helps write the code syntactically and wants to skip the execution. It is also considered a null operation as nothing happens when you execute the pass statement")
    printw(" ")

def a25():
    printw("This can be easily achieved by using the Shuffle() function from the random library as shown below:")
    printw("```")
    printw("from random import shuffle")
    printw("List = ['He', 'Loves', 'To', 'Code', 'In', 'Python']")
    printw("shuffle(List)")
    printw("print(List)")
    printw("```")
    printw("Output: ['Loves','He' ,'To ,'In', 'Python','Code']")
    printw(" ")

def a26():
    printw("To add a multiple lines comment in python, all the line should be prefixed by #.")
    printw(" ")

def a27():
    printw("Generally, Python is an all purpose Programming Language ,in addition to that Python is also Capable to perform scripting.")
    printw(" ")

def a28():
    printw("To access an element from ordered sequences, we simply use the index of the element, which is the position number of that particular element. The index usually starts from 0, i.e., the first element has index 0, the second has 1, and so on.When we use the index to access elements from the end of a list, it's called reverse indexing. In reverse indexing, the indexing of elements starts from the last element with the index number '−1'. The second last element has index '−2', and so on. These indexes used in reverse indexing are called negative indexes.")
    printw(" ")

def a29():
    printw("These methods belong to the Python RegEx 're' module and are used to modify strings.")
    printw("- split(): This method is used to split a given string into a list.")
    printw(" ")
    printw("- sub(): This method is used to find a substring where a regex pattern matches, and then it replaces the matched substring with a different string.")
    printw(" ")
    printw("- subn(): This method is similar to the sub() method, but it returns the new string, along with the number of replacements.")
    printw(" ")

def a30():
    printw("Literals refer to the data which will be provided to a given in a variable or constant.")
    printw(" ")
    printw("Literals supported by python are listed below:")
    printw("String Literals:")
    printw("- These literals are formed by enclosing text in the single or double quotes. For Example:")
    printw("- \"Intellipaat\"")
    printw("- '45879'")
    printw(" ")
    printw("Numeric Literals:")
    printw("- Python numeric literals support three types of literals")
    printw("- Integer: I=10")
    printw("- Float: i=5.2")
    printw("- Complex:1.73j")
    printw(" ")
    printw("Boolean Literals")
    printw("- Boolean literals help to denote boolean values. It contains either True or False.")
    printw("- x=True")
    printw(" ")

def a31():
    printw("The map() function in Python has two parameters, function and iterable. The map() function takes a function as an argument and then applies that function to all the elements of an iterable, passed to it as another argument. It returns an object list of results.")
    printw(" ")
    printw("For example:")
    printw("```")
    printw("def calculateSq(n):")
    printw("  return n*n")
    printw("numbers = (2, 3, 4, 5)")
    printw("result = map( calculateSq, numbers)")
    printw("print(result)")
    printw("```")
    printw(" ")

def a32():
    printw("Generator refers to the function that returns an iterable set of items.")
    printw(" ")

def a33():
    printw("These are the certain objects that are easily traversed and iterated when needed.")
    printw(" ")

def a34():
    printw("No. Python is a dynamically typed language, I.E., Python Interpreter automatically identifies the data type of a variable based on the type of value assigned to the variable.")
    printw(" ")

def a35():
    printw("Python comprehensions are like decorators, that help to build altered and filtered lists, dictionaries or sets from a given list, dictionary or set. Comprehension saves a lot of time and code that might be considerably more complex and time consuming.")
    printw(" ")
    printw("Comprehensions are beneficial in following scenarios:")
    printw("- Performing mathematical operations on the entire list")
    printw("- Performing conditional filtering operations on the entire list")
    printw("- Combining multiple lists into one")
    printw("- Flattening a multi-dimensional list")
    printw(" ")
    printw("For example:")
    printw("```")
    printw("my_list = [2, 3, 5, 7, 11]")
    printw("squared_list = [x**2 for x in my_list] # list comprehension")
    printw("# output => [4 , 9 , 25 , 49 , 121]")
    printw("squared_dict = {x:x**2 for x in my_list} # dict comprehension")
    printw("# output => {11: 121, 2: 4 , 3: 9 , 5: 25 , 7: 49}")
    printw("```")
    printw(" ")

def a36():
    printw("Comments are the statement used by the programmer to increase the readability of the code.With the help of # you can define the single comment and the other way to do commenting is to use the docstrings(strings enclosed within triple quotes).")
    printw(" ")
    printw("For example:")
    printw("```")
    printw("#Comments in Python ")
    printw("print(\"Comments in Python \")")
    printw("```")
    printw(" ")

def a37():
    printw("Yes, unlike Java, Python provides users with a wide range of support in terms of inheritance and its usage. Multiple inheritance refers to a scenario where a class is instantiated from more than one individual parent class. This provides a lot of functionality and advantages to users.")
    printw(" ")

def a38():
    printw("Functions in Python, range() and xrange() are used to iterate in a for loop for a fixed number of times. Functionality-wise, both these functions are the same. The difference comes when talking about Python version support for these functions and their return values.")
    printw(" ")
    printw("- range(): In Python 3, xrange() is not supported; instead, the range() function is used to iterate in for loops | xrange(): The xrange() function is used in Python 2 to iterate in for loops")
    printw(" ")
    printw("- range(): It returns a list | xrange(): It returns a generator object as it doesn't really generate a static list at the run time")
    printw(" ")
    printw("- range(): It takes more memory as it keeps the entire list of iterating numbers in memory | xrange(): It takes less memory as it keeps only one number at a time in memor")
    printw(" ")

def a39():
    printw("The Pickle module accepts the Python object and converts it into a string representation and stores it into a file by using the dump function. This process is called pickling. On the other hand, the process of retrieving the original Python objects fromthe string representation is called unpickling.")
    printw(" ")

def a40():
    printw("Tkinter is a built-in Python module that is used to create GUI applications. It is Python's standard toolkit for GUI development. Tkinter comes with Python, so there is no separate installation needed. You can start using it by importing it in your script.")
    printw(" ")

def a41():
    printw("Python does follow an object-oriented programming paradigm and has all the basic OOPs concepts such as inheritance, polymorphism, and more, with the exception of access specifiers. Python doesn't support strong encapsulation (adding a private keyword before data members). Although, it has a convention that can be used for data hiding, i.e., prefixing a data member with two underscores.")
    printw(" ")

def a42():
    printw("NumPy:")
    printw("- NumPy stands for Numerical Python")
    printw(" ")
    printw("- It is used for efficient and general numeric computations on numerical data saved in arrays. E.g., sorting, indexing, reshaping, and more")
    printw(" ")
    printw("- There are some linear algebraic functions available in this module, but they are not full-fledged")
    printw(" ")
    printw("SciPy:")
    printw("- SciPy stands for Scientific Python")
    printw(" ")
    printw("- This module is a collection of tools in Python used to perform operations such as integration, differentiation, and more")
    printw(" ")
    printw("- Full-fledged algebraic functions are available in SciPy for algebraic computations")
    printw(" ")

def a43():
    printw("Python has various file processing modes.")
    printw(" ")
    printw("For opening files, there are three modes:")
    printw("- read-only mode (r)")
    printw("- write-only mode (w)")
    printw("- read–write mode (rw)")
    printw(" ")
    printw("For opening a text file using the above modes, we will have to append 't' with them as follows:")
    printw("- read-only mode (rt)")
    printw("- write-only mode (wt)")
    printw("- read–write mode (rwt)")
    printw(" ")
    printw("Similarly, a binary file can be opened by appending 'b' with them as follows:")
    printw("- read-only mode (rb)")
    printw("- write-only mode (wb)")
    printw("- read–write mode (rwb)")
    printw(" ")
    printw("To append the content in the files, we can use the append mode (a):")
    printw("- For text files, the mode would be 'at'")
    printw("- For binary files, it would be 'ab'")
    printw(" ")

def a44():
    printw("Python comes with some file-related modules that have functions to manipulate text files and binary files in a file system. These modules can be used to create text or binary files, update their content, copy, delete, and more.Some file-related modules are os, os.path, and shutil.os. The os.path module has functions to access the file system, while the shutil.os module can be used to copy or delete files.")
    printw(" ")

def a45():
    printw("In Python, using the 'with' statement, we can open a file and close it as soon as the block of code, where 'with' is used, exits.")
    printw(" ")
    printw("In this way, we can opt for not using the close() method.")
    printw("```")
    printw("with open(\"filename\", \"mode\") as file_var:")
    printw("```")
    printw(" ")

def a46():
    printw("To display the contents of a file in reverse, the following code can be used:")
    printw("```")
    printw("for line in reversed(list(open(filename.txt))):")
    printw("    print(line.rstrip())")
    printw("```")
    printw(" ")

def a47():
    printw("1. xyz = 1,000,000")
    printw("2. x y z = 1000 2000 3000")
    printw("3. x,y,z = 1000, 2000, 3000")
    printw("4. x_y_z = 1,000,000")
    printw(" ")
    printw("Ans. 2 statement is invalid.")
    printw(" ")

def a48():
    printw("Command:")
    printw("```")
    printw("f = open(\"hello.txt\", \"wt\")")
    printw("```")
    printw(" ")

def a49():
    printw("len() is an inbuilt function used to calculate the length of sequence like list,string and array.")
    printw("```")
    printw("my_list=[1,2,3,4,5]")
    printw("len(my_list)")
    printw("```")
    printw(" ")

def a50():
    printw("- .*args: It is used to pass multiple arguments in a function.")
    printw(" ")
    printw("- **kwargs: It is used to pass multiple keyworded arguments in a function in python.")
    printw(" ")

def a51():
    printw("To remove duplicate elements from the list we use the set() function.")
    printw(" ")
    printw("Consider the below example:")
    printw("```")
    printw("demo_list=[5,4,4,6,8,12,12,1,5]")
    printw("unique_list = list(set(demo_list))")
    printw("output:[1,5,6,8,12]")
    printw("```")
    printw(" ")

def a52():
    printw("You need to import the OS Module and use os.remove() function for deleting a file in python.")
    printw(" ")
    printw("consider the code below:")
    printw("```")
    printw("import os")
    printw("os.remove(\"file_name.txt\")")
    printw("```")
    printw(" ")

def a53():
    printw("We can read a random line in a file using the random module.")
    printw(" ")
    printw("For example:")
    printw("```")
    printw("import random")
    printw("def read_random(fname):")
    printw("lines = open(fname).read().splitlines()")
    printw("return random.choice(lines)")
    printw("print(read_random ('hello.txt'))")
    printw("```")
    printw(" ")

def a54():
    printw("```")
    printw("def file_count(fname):")
    printw("    with open(fname) as f:")
    printw("        for i, 1 in enumerate(f):")
    printw("            pass")
    printw("        return i+1")
    printw("print(\"Total number of lines in the text file: \", file_count(\"file.txt\"))")
    printw("```")
    printw(" ")

def a55():
    printw("```")
    printw("list1 = [2, 33, 222, 14, 25]")
    printw("print(list1[-2])")
    printw("```")
    printw("Ans: 14")
    printw(" ")

def a56():
    printw("Operators are referred to as special functions that take one or more values(operands) and produce a corresponding result.")
    printw("- is: returns the true value when both the operands are true (Example: \"x\" is 'x')")
    printw(" ")
    printw("- not: returns the inverse of the boolean value based upon the operands (example:\"1\" returns \"0\" and vice-versa.")
    printw(" ")
    printw("- In: helps to check if the element is present in a given Sequence or not.")
    printw(" ")

def a57():
    printw("Whenever Python exits, especially those Python modules which are having circular references to other objects or the objects that are referenced from the global namespaces are not always de-allocated or freed.")
    printw("- It is not possible to de-allocate those portions of memory that are reserved by the C library.")
    printw(" ")
    printw("- On exit, because of having its own efficient clean up mechanism, Python would try to de-allocate every object.")
    printw(" ")

def a58():
    printw("Ternary operator is the operator that is used to show the conditional statements in Python. This consists of the boolean true or false values with a statement that has to be checked.")
    printw(" ")
    printw("Syntax:")
    printw("```")
    printw("[on_true] if [expression] else [on_false]x, y = 10, 20 count = x if x < y else y")
    printw("```")
    printw(" ")
    printw("Explanation:")
    printw("The above expression is evaluated like if x<y else y, in this case if x<y is true then the value is returned as count=x and if it is incorrect then count=y will be stored to result.")
    printw(" ")

def a59():
    printw("In python, adding elements in an array can be easily done with the help of extend(),append() and insert() functions.")
    printw(" ")
    printw("Consider the following example:")
    printw("```")
    printw("x=arr.array('d', [11.1 , 2.1 ,3.1] )")
    printw("x.append(10.1)")
    printw("print(x) #[11.1,2.1,3.1,10.1]")
    printw("x.extend([8.3,1.3,5.3])")
    printw("print(x) #[11.1,2.1,3.1,10.1,8.3,1.3,5.3]")
    printw("x.insert(2,6.2)")
    printw("print(x) # [11.1,2.1,6.2,3.1,10.1,8.3,1.3,5.3]")
    printw("```")
    printw(" ")

def a60():
    printw("Elements can be removed from the python array using pop() or remove() methods.")
    printw("- pop(): This function will return the removed element .")
    printw("- remove():It will not return the removed element.")
    printw(" ")
    printw("Consider the below example:")
    printw("```")
    printw("x=arr.array('d', [8.1, 2.4, 6.8, 1.1, 7.7, 1.2, 3.6])")
    printw("print(x.pop())")
    printw("print(x.pop(3))")
    printw("x.remove(8.1)")
    printw("print(x)")
    printw("Output:")
    printw("3.6")
    printw("1.1 # element popped at 3 rd index")
    printw("array('d', [ 2.4, 6.8, 7.7, 1.2])")
    printw("```")
    printw(" ")

def a61():
    printw("The following code can be used to sort a numerical list in Python:")
    printw("```")
    printw("list = [\"2\", \"5\", \"7\", \"8\", \"1\"]")
    printw("list = [int(i) for i in list]")
    printw("list.sort()")
    printw("print(list)")
    printw("```")
    printw(" ")

def a62():
    printw("The normal solution for this problem statement would be as follows:")
    printw("```")
    printw("with open(SOME_LARGE_FILE) as countletter:")
    printw("    count = 0")
    printw("    text = countletter.read()")
    printw("    for character in text:")
    printw("        if character.isupper():")
    printw("            count += 1")
    printw("```")
    printw(" ")
    printw("To make this code more efficient, the whole code block can be converted into a one-liner code using the feature called generator expression. With this, the equivalent code line of the above code block would be as follows:")
    printw("```")
    printw("count sum(1 for line in countletter for character in line if character.isupper())")
    printw("```")
    printw(" ")

def a63():
    printw("The function list.reverse() reverses the objects of a list.")
    printw(" ")

def a64():
    printw("```")
    printw("list.pop(obj=list[-1]):")
    printw("```")
    printw("Here, -1 represents the last element of the list. Hence, the pop() function removes the last object (obj) from the list.")
    printw(" ")

def a65():
    printw("This achieved with importing the random module,it is the module that is used to generate random numbers.")
    printw(" ")
    printw("Syntax:")
    printw("```")
    printw("import random")
    printw("random.random # returns the floating point random number between the range of [0,1].")
    printw("```")
    printw(" ")

def a66():
    printw("lower() function is used to convert a string to lowercase.")
    printw(" ")
    printw("For Example:")
    printw("```")
    printw("demo_string='ROSES'")
    printw("print(demo_string.lower())")
    printw("```")
    printw(" ")

def a67():
    printw("NumPy arrays provide users with three main advantages as shown below:")
    printw("- NumPy arrays consume a lot less memory, thereby making the code more efficient.")
    printw(" ")
    printw("- NumPy arrays execute faster and do not add heavy processing to the runtime.")
    printw(" ")
    printw("- NumPy has a highly readable syntax, making it easy and convenient for programmers.")
    printw(" ")

def a68():
    printw("Polymorphism is the ability of the code to take multiple forms. Let's say, if the parent class has a method named XYZ then the child class can also have a method with the same name XYZ having its own variables and parameters.")
    printw(" ")

def a69():
    printw("encapsulation in Python refers to the process of wrapping up the variables and different functions into a single entity or capsule.Python class is the best example of encapsulation in python.")
    printw(" ")

def a70():
    printw("Nested Lists:")
    printw("- Python lists are efficient general-purpose containers that support efficient operations like insertion,appending,deletion and concatenation.")
    printw(" ")
    printw("- The limitations of lists are that they don't support “vectorized” operations like element wise addition and multiplication, and the fact that they can contain objects of differing types mean that Python must store type information for every element, and must execute type dispatching code when operating on each element.")
    printw(" ")
    printw("Numpy:")
    printw("- NumPy is more efficient and more convenient as you get a lot of vector and matrix operations for free, which helps to avoid unnecessary work and complexity of the code.Numpy is also efficiently implemented when compared to nested")
    printw(" ")
    printw("- NumPy array is faster and contains a lot of built-in functions which will help in FFTs, convolutions, fast searching, linear algebra,basic statistics, histograms,etc.")
    printw(" ")

def a71():
    printw("A lambda function is an anonymous function (a function that does not have a name) in Python. To define anonymous functions, we use the 'lambda' keyword instead of the 'def' keyword, hence the name 'lambda function'. Lambda functions can have any number of arguments but only one statement.")
    printw(" ")
    printw("For example:")
    printw("```")
    printw("l = lambda x,y : x*y")
    printw("print(a(5, 6))")
    printw("```")
    printw("Output:30")
    printw(" ")

def a72():
    printw("Self is an object or an instance of a class. This is explicitly included as the first parameter in Python. On the other hand, in Java it is optional. It helps differentiate between the methods and attributes of a class with local variables.")
    printw(" ")
    printw("The self variable in the init method refers to the newly created object, while in other methods, it refers to the object whose method was called.")
    printw(" ")
    printw("Syntax:")
    printw("```")
    printw("Class A:")
    printw("def func(self):")
    printw("print(“Hi”)")
    printw("```")
    printw(" ")

def a73():
    printw("Both append() and extend() methods are methods used to add elements at the end of a list.")
    printw("- append(element): Adds the given element at the end of the list that called this append() method")
    printw(" ")
    printw("- extend(another-list): Adds the elements of another list at the end of the list that called this extend() method")
    printw(" ")

def a74():
    printw("Flask supports a database-powered application (RDBS). Such a system requires creating a schema, which needs piping the schema.sql file into the sqlite3 command. Python developers need to install the sqlite3 command to create or initiate the database in Flask.")
    printw(" ")
    printw("Flask allows to request for a database in three ways:")
    printw("- before_request(): They are called before a request and pass no arguments.")
    printw(" ")
    printw("- after_request(): They are called after a request and pass the response that will be sent to the client.")
    printw(" ")
    printw("- teardown_request(): They are called in a situation when an exception is raised and responses are not guaranteed. They are called after the response has been constructed. They are not allowed to modify the request, and their values are ignored.")
    printw(" ")

def a75():
    printw("Python lets users include a description (or quick notes) for their methods using documentation strings or docstrings. Docstrings are different from regular comments in Python as, rather than being completely ignored by the Python Interpreter like in the case of comments, these are defined within triple quotes.")
    printw(" ")
    printw("Syntax:")
    printw("```")
    printw("\"\"\"")
    printw("Using docstring as a comment.")
    printw("This code add two numbers")
    printw("\"\"\"")
    printw("x=7")
    printw("y=9")
    printw("z=x+y")
    printw("print(z)")
    printw("```")
    printw(" ")

def a76():
    printw("Python has a multi-threading package ,but commonly not considered as good practice to use it as it will result in increased code execution time.")
    printw(" ")
    printw("- Python has a constructor called the Global Interpreter Lock (GIL). The GIL ensures that only one of your 'threads' can execute at one time.The process makes sure that a thread acquires the GIL, does a little work, then passes the GIL onto the next thread.")
    printw(" ")
    printw("- This happens at a very Quick instance of time and that's why to the human eye it seems like your threads are executing parallely, but in reality they are executing one by one by just taking turns using the same CPU core.")
    printw(" ")

def a77():
    printw("Slicing is a process used to select a range of elements from sequence data type like list, string and tuple. Slicing is beneficial and easy to extract out the elements. It requires a : (colon) which separates the start index and end index of the field. All the data sequence types List or tuple allows us to use slicing to get the needed elements. Although we can get elements by specifying an index, we get only a single element whereas using slicing we can get a group or appropriate range of needed elements.")
    printw(" ")
    printw("Syntax:")
    printw("```")
    printw("List_name[start:stop]")
    printw("```")
    printw(" ")

def a78():
    printw("- Functional programming is a coding style where the main source of logic in a program comes from functions.")
    printw(" ")
    printw("- Incorporating functional programming in our codes means writing pure functions.")
    printw(" ")
    printw("- Pure functions are functions that cause little or no changes outside the scope of the function. These changes are referred to as side effects. To reduce side effects, pure functions are used, which makes the code easy-to-follow, test, or debug.")
    printw(" ")
    printw("- Python does follow a functional programming style. Following are some examples of functional programming in Python:")
    printw("```")
    printw("filter(): Filter lets us filter some values based on a conditional logic.")
    printw(" ")
    printw("list(filter(lambda x:x>6,range(9))) [7, 8]")
    printw(" ")
    printw("map(): Map applies a function to every element in an iterable.")
    printw(" ")
    printw("list(map(lambda x:x**2,range(5))) [0, 1, 4, 9, 16, 25]")
    printw(" ")
    printw("reduce(): Reduce repeatedly reduces a sequence pair-wise until it reaches a single value.")
    printw(" ")
    printw("from functools import reduce >>> reduce(lambda x,y:x-y,[1,2,3,4,5]) -1")
    printw("````")
    printw(" ")

def a79():
    printw("1. set([[1,2],[3,4],[4,5]])")
    printw("2. set([1,2,2,3,4,5])")
    printw("3. {1,2,3,4}")
    printw("4. set((1,2,3,4))")
    printw(" ")
    printw("Ans.")
    printw("set([[1,2],[3,4],[4,5]])")
    printw("Explanation: The argument given for the set must be iterable.")
    printw(" ")

def a80():
    printw("Monkey patching is the term used to denote the modifications that are done to a class or a module during the runtime. This can only be done as Python supports changes in the behavior of the program while being executed.")
    printw(" ")
    printw("The following is an example, denoting monkey patching in Python:")
    printw("```")
    printw("# monkeyy.py")
    printw("class X:")
    printw("def func(self):")
    printw("print \"func() is being called\"")
    printw("```")
    printw(" ")
    printw("The above module (monkeyy) is used to change the behavior of a function at the runtime as shown below:")
    printw("```")
    printw("import monkeyy")
    printw("def monkey_f(self):")
    printw("print \"monkey_f() is being called\"")
    printw("# replacing address of “func” with “monkey_f”")
    printw("monkeyy.X.func = monkey_f")
    printw("obj = monk.X()")
    printw("# calling function “func” whose address got replaced")
    printw("# with function “monkey_f()”")
    printw("obj.func()")
    printw("```")
    printw(" ")

def a81():
    printw("/ : is a division operator and returns the Quotient value.")
    printw("10/3")
    printw("3.33")
    printw(" ")
    printw("// : is known as floor division operator and used to return only the value of quotient before decimal")
    printw("10//3")
    printw("3")
    printw(" ")

def a82():
    printw("Pandas is an open source python library which supports data structures for data based operations associated with data analyzing and data Manipulation . Pandas with its rich sets of features fits in every role of data operation,whether it be related to implementing different algorithms or for solving complex business problems. Pandas helps to deal with a number of files in performing certain operations on the data stored by files.")
    printw(" ")

def a83():
    printw("A dataframe refers to a two dimensional mutable data structure or data aligned in the tabular form with labeled axes(rows and column).")
    printw(" ")
    printw("Syntax:")
    printw("pandas.DataFrame( data, index, columns, dtype)")
    printw("- data:It refers to various forms like ndarray, series, map, lists, dict, constants and can take other DataFrame as Input.")
    printw(" ")
    printw("- index:This argument is optional as the index for row labels will be automatically taken care of by pandas library.")
    printw(" ")
    printw("- columns:This argument is optional as the index for column labels will be automatically taken care of by pandas library.")
    printw(" ")
    printw("- Dtype: refers to the data type of each column.")
    printw(" ")

def a84():
    printw("The different dataframes can be easily combined with the help of functions listed below:")
    printw("- Append(): This function is used for horizontal stacking of dataframes.")
    printw("```")
    printw("data_frame1.append(data_frame2)")
    printw("```")
    printw(" ")
    printw("- concat(): This function is used for vertical stacking and best suites when the dataframes to be combined possess the same column and similar fields.")
    printw("```")
    printw("pd.concat([data_frame1, data_frame2])")
    printw("```")
    printw(" ")
    printw("- join(): This function is used to extract data from different dataframes which have one or more columns common.")
    printw("```")
    printw("data_frame1.join(data_frame2)")
    printw("```")
    printw(" ")

def a85():
    printw("Identification:")
    printw("- isnull() and isna() functions are used to identify the missing values in your data loaded into dataframe.")
    printw("```")
    printw("missing_count=data_frame1.isnull().sum()")
    printw("```")
    printw(" ")
    printw("Handling missing Values:")
    printw("There are two ways of handling the missing values :")
    printw("- Replace the missing values with 0")
    printw("```")
    printw("df['col_name'].fillna(0)")
    printw("```")
    printw(" ")
    printw("- Replace the missing values with the mean value of that column")
    printw("```")
    printw("df['col_name'] = df['col_name'].fillna((df['col_name'].mean()))")
    printw("```")
    printw(" ")

def a86():
    printw("Regression is termed as supervised machine learning algorithm technique which is used to find the correlation between variables and help to predict dependent variable(y) based upon the independent variable (x). It is mainly used for prediction, time series modeling,forecasting and determining the causal-effect relationship between variables.")
    printw(" ")
    printw("Scikit library is used in python to implement the regression and all machine learning algorithms.")
    printw(" ")
    printw("There are two different type of regression algorithm in machine learning:")
    printw("- Linear Regression: Used when the variables are continuous and numeric in nature.")
    printw("- Logistic Regression: Used when the variables are continuous and categorical in nature.")
    printw(" ")

def a87():
    printw("Classification refers to a predictive modeling process where a class label is predicted for a given example of input data. It helps categorize the provided input into a label that other observations with similar features have. For example, it can be used for classifying a mail whether it is spam or not or for checking whether users will churn or not based on their behavior.")
    printw(" ")
    printw("These are some of the classification algorithms used in Machine Learning:")
    printw("- Decision tree")
    printw("- Random forest classifier")
    printw("- Support vector machine")
    printw(" ")

def a88():
    printw("This can be achieved by using the scikit machine learning library and importing train_test_split function in python as shown below:")
    printw("```")
    printw("Import sklearn.model_selection.train_test_split")
    printw("# test size =30% and train= 70 %")
    printw("X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.33, random_state=0).")
    printw("```")
    printw(" ")

def a89():
    printw("Support vector machine (SVM) is a supervised machine learning model that considers the classification algorithms for twogroup classification problems.Support vector machine is a representation of the training data as points in space are separated into categories with the help of a clear gap that should be as wide as possible.")
    printw(" ")

def a90():
    printw("We can get the indices of N maximum values from a NumPy array using the below code:")
    printw("```")
    printw("import numpy as np")
    printw("ar = np.array([1, 3, 2, 4, 5, 6])")
    printw("print(ar.argsort()[-3:][::-1])")
    printw("```")
    printw(" ")

def a91():
    printw("The easiest and the most efficient way you can calculate percentiles in Python is to make use of NumPy arrays and its functions.")
    printw(" ")
    printw("Consider the following example:")
    printw("```")
    printw("import numpy as np")
    printw("a = np.array([1,2,3,4,5,6,7])")
    printw("p = np.percentile(a, 50) #Returns the 50th percentile which is also the median")
    printw("print(p)")
    printw("```")
    printw(" ")

def a92():
    printw("A palindrome is a word, phrase, or sequence that reads the same backward as forward, e.g., madam, nurses run, etc.")
    printw(" ")
    printw("Consider the below code:")
    printw("```")
    printw("def fun(string):")
    printw("s1 = string")
    printw("s = string[::-1]")
    printw("if(s1 == s):")
    printw("    return true")
    printw("else:")
    printw("    return false")
    printw("print(fun(\"madam\"))")
    printw("```")
    printw(" ")

def a93():
    print("```")
    print("def sum(num):")
    print("    if len(num) == 1:")
    print("        return num[0] #with only one element in the list, the sum result will be equal to the element.")
    print("    else:")
    print("        return num[0] + sum(num[1:])")
    print("print(sum([2, 4, 5, 6, 7]))")
    print("```")
    printw(" ")

def a94():
    print("```")
    print("def bubbleSort(x):")
    print("    n = len(x)")
    print("    # Traverse through all array elements")
    print("    for i in range(n-1):")
    print("        for j in range(0, n-i-1):")
    print("            if x[j] > x[j+1] :")
    print("                x[j], x[j+1] = x[j+1], x[j]")
    print("# Driver code to test above")
    print("arr = [25, 34,47, 21, 22, 11,37]")
    print("bubbleSort(arr)")
    print("print(\"Sorted array is:\")")
    print("for i in range(len(arr)):")
    print("    print (\"%d\" %arr[i]),")
    print("```")
    printw("Output:")
    printw("11,21,22,25,34,37,47")
    printw(" ")

def a95():
    printw("```")
    printw("def Star_triangle(n):")
    printw("for x in range(n):")
    printw("    print(' '*(n-x-1)+'*'*(2*x+1))")
    printw("Star_triangle(9)")
    printw("```")
    printw(" ")
    printw("Output:")
    printw("*")
    printw("***")
    printw("*****")
    printw("*******")
    printw("*********")
    printw("***********")
    printw("*************")
    printw("***************")
    printw("*****************")
    printw(" ")
    
def a96():
    print("Fibonacci series refers to the series where the element is the sum of two elements prior to it.")
    print("```")
    print("n = int(input(\"number of terms?\"))")
    print("n1, n2 = 0, 1")
    print(" ")
    print("count = 0")
    print("if n <= 0:")
    print("    print(\"Please enter a positive integer\")")
    print("elif n == 1:")
    print("    print(\"Fibonacci sequence upto\",nterms,\":\")")
    print("    print(n1)")
    print("else:")
    print("    print(\"Fibonacci sequence:\")")
    print(" ")
    print("while count < n:")
    print("    print(n1)")
    print("    nth = n1 + n2")
    print("    n1 = n2")
    print("    n2 = nth")
    print("    count += 1")
    print("```")
    printw(" ")

def a97():
    print("```")
    print("num = 13")
    print("if num > 1:")
    print("    for i in range(2, int(num/2)+1):")
    print("        if (num % i) == 0:")
    print("            print(num, \"is not a prime number\")")
    print("            break")
    print("        else:")
    print("            print(num, \"is a prime number\")")
    print("else:")
    print("    print(num, \"is not a prime number\")")
    print("```")
    print("Output: 13 is a prime number")
    printw(" ")

def a98():
    print("code to sort a list in Python:")
    print("```")
    print("my_list = [\"8\", \"4\", \"3\", \"6\", \"2\"]")
    print("my_list = [int(i) for i in list]")
    print("my_list.sort()")
    print("print (my_list)")
    print("```")
    print("Output: 2,3,4,6,8")
    printw(" ")

def a99():
    print("```")
    print("x = 'a'")
    print("# print the ASCII value of assigned character stored in x")
    print("print(\" ASCII value of '\" + x + \"' is\", ord(x))")
    print("```")
    print("Output: 65")
    printw(" ")

def a100():
    printw("These two keywords are used to change the scope of a previously declared variable. nolocal is often used when you need to access a variable in a nested function:")
    printw("```")
    printw("def func1():")
    printw("    x = 5")
    printw("    def func2():")
    printw("    nolocal x")
    printw("    print(x)")
    printw("    func2()")
    printw("```")
    printw(" ")
    printw("global is a more straightforward instruction. It makes a previously declared variable global. For example, consider this code:")
    printw("```")
    printw("x = 5")
    printw("def func1():")
    printw("    print(x)")
    printw("func1()")
    printw("> 5")
    printw("```")
    printw(" ")
    printw("Since x is declared before function call, func1 can access it. However, if you try to change it:")
    printw("```")
    printw("x = 5")
    printw("def func2():")
    printw("    x += 3")
    printw("func2()")
    printw("> UnboundLocalError: local variable 'c' referenced before assignment")
    printw("```")
    printw(" ")
    printw("To make it work, we need to indicate that by x we mean the global variable x:")
    printw("```")
    printw("x = 5")
    printw("def func2():")
    printw("    global x")
    printw("    x += 3")
    printw("func2()")
    printw("```")
    printw(" ")

def a101():
    printw("Both of them define a class method that can be called without instantiating an object of the class. The only difference is in their signature:")
    printw("```")
    printw("class A:")
    printw("    @staticmethod")
    printw("    def func1():")
    printw("       pass")
    printw(" ")
    printw("    @classmethod")
    printw("    def func2(cls):")
    printw("       pass")
    printw("```")
    printw(" ")
    printw("As you can see, the classmethod accepts an implicit argument cls, which will be set to the class A itself. Once common use case for classmethod is creating alternative inheritable constructors.")
    printw(" ")

def a102():
    printw("GIL stands for the Global Interpreter Lock and it is a mechanism Python is using for concurrency. It is built in deep into Python system and it is not possible at the moment to get rid of it. The major downside of GIL is that it makes threading not truly concurrent. It locks the interpreter, and even though it looks like you are working with threads, they are not executed at the same time, resulting in performance losses. Here are some ways of getting around it:")
    printw(" ")
    printw("- multiprocessing module. It lets you spawn new Python processes and manage them the same way you would manage threads")
    printw(" ")
    printw("- asyncio module. It effectively enables asyncronous programming and adds the async/await syntax. While it does not solve the GIL problem, it will make the code way more readable and clearer.")
    printw(" ")
    printw("- Stackless Python. This is a fork of Python without GIL. It’s most notable use is as a backend for the EVE Online game")
    printw(" ")

def a103():
    printw("Metaclasses are classes for classes. A metaclass can specify certain behaviour that is common for many classes for cases when inheritance will be too messy. One common metaclass is ABCMeta, which is used to create abstract classes.")
    printw(" ")
    printw("Metaclasses and metaprogramming in Python is a huge topics, and feel free to read this if you are interested in it.")
    printw(" ")

def a104():
    printw("While Python is a dynamically typed language, there is a way to annotate types for clarity purposes. These are the built-in types:")
    printw("- int")
    printw("- float")
    printw("- bool")
    printw("- str")
    printw("- bytes")
    printw(" ")
    printw("Complex types are available from the typing module:")
    printw("- List")
    printw("- Set")
    printw("- Dict")
    printw("- Tuple")
    printw("- Optional")
    printw("- etc.")
    printw(" ")
    printw("Here is how you would define a function with type annotations:")
    printw("```")
    printw("def func1(x: int, y: str) -> bool:")
    printw("    return False")
    printw("```")
    printw(" ")
    printw("Generic type annotations are annotations that take another type as a parameter, allowing you to specify complex logic:")
    printw("- List[int]")
    printw("- Optional[List[int]]")
    printw("- Tuple[bool]")
    printw("- etc.")
    printw(" ")
    printw("Note that these are only used for warnings and static type checking. You will not be guaranteed these types at runtime.")
    printw(" ")

def a105():
    printw("Generator functions are functions that can suspend their execution after returning a value, in order to resume it at some later time and return another value. This is made possible by the yield keyword, which you use in place of return. The most common generator function you have worked with is the range. Here is one way of implementing it (only works with positive step, I will leave it as an exercise to make one that supports negative steps):")
    printw("```")
    printw("def range(start, end, step):")
    printw("    cur = start")
    printw("    while cur > end:")
    printw("    yield cur")
    printw("    cur += step")
    printw("```")
    printw(" ")

def a106():
    printw("Decorators in Python are used to modify behaviours of functions. For example, if you want to log all calls to a particular set of functions, cache its parameters and return values, perform benchmarks, etc.")
    printw(" ")
    printw("Decorators are prefixed with the @ symbol and placed right before function declaration:")
    printw("```")
    printw("@my_decorator")
    printw("def func1():")
    printw("    pass")
    printw("```")
    printw(" ")

def a107():
    printw("Pickling is just the Python way of saying serializing. Pickling lets you serialize an object into a string (or anything else you choose) in order to be persisted on storage or sent over network. Unpickling is the process of restoring the original object from a pickled string.")
    printw(" ")
    printw("Pickle is NOT secure. Only unpickle objects from trusted.")
    printw(" ")
    printw("Here is how you would pickle a basic data structure:")
    printw("```")
    printw("import pickle")
    printw("cars = {\"Subaru\": \"best car\", \"Toyota\": \"no i am the best car\"}")
    printw("cars_serialized = pickle.dumps(cars)")
    printw("# cars_serialized is a byte string")
    printw("new_cars = pickle.loads(cars_serialized)")
    printw("```")
    printw(" ")

def a108():
    printw("These deal closely with unpacking. If you put *args in function’s parameter list, all unnamed arguments will be stored in the args array. **kwargs works the same way, but for named parameters:")
    printw("```")
    printw("def func1(*args, **kwargs):")
    printw("    print(args)")
    printw("    print(kwargs)")
    printw("func1(1, 'abc', lol='lmao')")
    printw("> [1, 'abc']")
    printw("> {\"lol\": \"lmao\"}")
    printw("```")
    printw(" ")

def a109():
    printw(".pyc files contain Python bytecode, same way as .class files in Java. Python is still considered an interpreted language, though, since this compilation phase occurs when you run the program, while in Java these a clearly separated")
    printw(" ")

def a110():
    printw("You define an abstract class by inheriting the ABC class from the abc module:")
    printw("```")
    printw("from abc import ABC")
    printw("class AbstractCar(ABC):")
    printw("    @abstractmethod")
    printw("    def drive(self):")
    printw("       pass")
    printw("```")
    printw(" ")
    printw("To implement the class, just inherit it:")
    printw("class ToyotaSupra(AbstractCar):")
    printw("    def drive(self):")
    printw("       print('brrrr sutututu')")
    printw("```")
    printw(" ")

def generate():
    with open(FILE, "r") as fp:
        question_list = fp.readlines()
        num_questions = len(question_list)
        ii_random = random.randint(0, num_questions-1)
        # Question
        q = question_list[ii_random]
        # Answer 
        # Capture the output of a()
        output = StringIO()
        with redirect_stdout(output):
            eval("".join(["a", str(ii_random), "()"]))
        # Get the output as a string
        a = output.getvalue()

        # Now build the output string
        output_list = [
            "!!! QUESTION:\n",
            "-------------\n",
            "".join([q, "\n\n\n\n"]),
            "!!! ANSWER:\n",
            "-----------\n",
            "".join([a, "\n"]),
        ]

        output = "".join(output_list)
        return output

def main():
    generate()


if __name__=="__main__":
    main()
